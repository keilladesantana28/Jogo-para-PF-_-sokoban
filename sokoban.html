<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sokoban</title>
</head>
<body>
  <canvas 
    width="1400" 
    height="800" 
    id="game" 
    style="border: 1px solid black"
    ></canvas> /*define tamanho de tela*/

  <script>
    const canvas = document.getElementById("game"); //Resgata o elemento canvas pelo id "game"
    const context = canvas.getContext("2d");// faz ter acesso ao context para possibilitar realizar desenhos no canvas

    const types = {
      wall: "#", //paredes
      player: "@",//jogador
      playerOnGoal: "+", //jogador quando na posição onde deveriam estar as caixas
      block: "$", //caixas
      blockOnGoal: "*", //caixas na posição correta
      goal: ".",// local para posicionar as caixas
      empty: " " // chão que pode ser percorrido(geralmente limitados por paredes)
    }; //define elementos  que serão inseridos no canvas 

    const level1 = `
    #####
    #   #
    #$  #
  ###  $##
  #  $ $ #
### # ## #   ######
#   # ## #####  ..#
# $  $          ..#
##### ### #@##  ..#
    #     #########
    #######        
    `;
/*define desenho dos níveis:
sugestão nível 1
########
#      #
#@ $   #
#   $  #
# . .  #
########
nivel 2
########
#     .#
#@ $   #
#   $  #
# . *  #
########
nivel 3

########
#      #
#  $   #
#   $  #
# + .  #
########
o primeiro ser nivel 4 ja esta no jogo 
#####
###@ .#
# $ #.#
#  $$ #
#.  # #
#   $.#
#######*/
    const grid = 32;
    const cells = []; // cria matriz com cada linha definida em const como uma celula dentro da matriz
    let playerPos = {row: 0, col: 0}; // define posição do jogador dentro da matriz row-> linha col-> coluna da matriz
    let playerDir = {row: 0, col: 0};

    let linhas = level1.split("\n").filter(l => l.trim().length > 0); /*cria um array de strings para cada linha definida por level1 e remove a priemeira lina vazia e a fase começa na linha 0*/
    let width = 0; //armazena a largura total do mapa

    linhas.forEach((linha, row) => { // percorre as linhas e row é o indice
      cells[row] = []; //representa as colunas
      if (linha.length > width) width = linha.length;// verifica tamanho das linhas para saber o tamanho do mapa em colunas
      linha.split("").forEach((caractere, col) => { // transforma cada linha em um array de caractere(um para cada célula) 
        cells[row][col] = caractere;
        if (c === types.player || c === types.playerOnGoal) {
          playerPos = {row, col};
        }
      });
    });

    canvas.width = width * grid; 
    canvas.height = cells.length * grid;

    function move(startPos, endPos) {
      const startCell = cells[startPos.row][startPos.col];
      const endCell = cells[endPos.row][endPos.col];

      const isPlayer = (startCell === types.player || startCell === types.playerOnGoal);

      // limpa posição inicial
      if (startCell === types.player || startCell === types.block)
        cells[startPos.row][startPos.col] = types.empty;
      else
        cells[startPos.row][startPos.col] = types.goal;

      // coloca na posição final
      if (endCell === types.empty)
        cells[endPos.row][endPos.col] = isPlayer ? types.player : types.block;
      else if (endCell === types.goal)
        cells[endPos.row][endPos.col] = isPlayer ? types.playerOnGoal : types.blockOnGoal;
    }

    function draw() {
      context.clearRect(0,0,canvas.width,canvas.height);

      let allBlocksOnGoal = true;

      for (let row=0; row<cells.length; row++) {
        for (let col=0; col<cells[row].length; col++) {
          const cell = cells[row][col];

          if (cell === types.wall) {
            context.fillStyle = "gray";
            context.fillRect(col*grid, row*grid, grid, grid);
          }

          if (cell === types.block || cell === types.blockOnGoal) {
            context.fillStyle = (cell === types.block) ? "orange" : "green";
            context.fillRect(col*grid, row*grid, grid, grid);
            if (cell === types.block) allBlocksOnGoal = false;
          }

          if (cell === types.goal) {
            context.strokeStyle = "red";
            context.beginPath();
            context.moveTo(col*grid+10, row*grid+10);
            context.lineTo(col*grid+grid-10, row*grid+grid-10);
            context.stroke();
            context.closePath();
          }

          if (cell === types.player || cell === types.playerOnGoal) {
            context.fillStyle = "pink";
            context.beginPath();
            context.arc((col+0.5)*grid,(row+0.5)*grid,grid/3,0,Math.PI*2);
            context.fill();
            context.closePath();
          }
        }
      }

      if (allBlocksOnGoal) {
        context.fillStyle = "black";
        context.font = "30px Arial";
        context.fillText("VOCÊ VENCEU!", 50, 50);
      }
    }

    function update() {
      const row = playerPos.row + playerDir.row;
      const col = playerPos.col + playerDir.col;
      const cell = cells[row][col];

      switch(cell) {
        case types.empty:
        case types.goal:
          move(playerPos,{row,col});
          playerPos = {row,col};
          break;

        case types.block:
        case types.blockOnGoal:
          const nextRow = row + playerDir.row;
          const nextCol = col + playerDir.col;
          const nextCell = cells[nextRow][nextCol];
          if (nextCell === types.empty || nextCell === types.goal) {
            move({row,col}, {row:nextRow,col:nextCol});
            move(playerPos,{row,col});
            playerPos = {row,col};
          }
          break;
      }

      playerDir = {row:0,col:0};
    }

    document.addEventListener("keydown", (e) => {
      if (e.key === "ArrowUp") playerDir = {row:-1,col:0};
      if (e.key === "ArrowDown") playerDir = {row:1,col:0};
      if (e.key === "ArrowLeft") playerDir = {row:0,col:-1};
      if (e.key === "ArrowRight") playerDir = {row:0,col:1};
      update();
      draw();
    });

    draw();
  </script>
</body>
  </html>
