<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sokoban</title>
    <style>
        /* o css embutido define aparencia do mapa e de cada elemento do jogo */
        body {
            margin: 0;
            font-family: Arial, sans-serif;
            background: #000000;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }

        /* telas sobrepostas */
        .tela {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0,0,0,0.9);
            z-index: 10;
        }

         /* define o estilo e a aparencia principal do menu */
        .tela h1 {
            font-size: 60px;
            color: #ff6600;
            text-shadow: 3px 3px #000;
        }

        /* define o estilo para os botoes na tela do menu */
        .tela button {
            margin-top: 20px;
            padding: 12px 24px;
            font-size: 20px;
            border: none;
            border-radius: 8px;
            background: #1f1094;
            color: white;
            cursor: pointer;
            transition: 0.3s;
        }
        
        /* Efeito visual ao passar o mouse sobre os bot√µes. */
        .tela button:hover {
            background: #2200ff;
        }
        
        /* Define o estilo da tela do jogo. */
        #game {
            border: 2px solid rgb(0, 0, 0);
            background: #000000;
        }
    </style>
</head>
<body>

    <!-- Tela inicial -->
    <div id="tela-inicial" class="tela">
        <h1>üéÆ Sokoban üéÆ</h1>
        <button onclick="iniciarJogo()">Jogar</button>
    </div>
    
    <!-- Tela de vit√≥ria -->
    <div id="tela-vitoria" class="tela" style="display: none;">
        <h1>üèÜ Voc√™ Venceu! üèÜ</h1>
        <button onclick="reiniciarJogo()">Reiniciar</button>
    </div>

    <!-- √Årea do jogo -->
    <canvas id="game" width="1400" height="800"></canvas>

    <script>
       /* O c√≥digo JavaScript √© utilizado neste escopo para garantir que ele s√≥
¬† ¬† ¬† ¬†  seja executado depois que todo o HTML da p√°gina for carregado */
        document.addEventListener("DOMContentLoaded", () => {
            // Refer√™ncias aos elementos do canvas e o contexto 2D para desenhar.
            const canvas = document.getElementById("game");
            const context = canvas.getContext("2d");
            const grid = 32; // Tamanho de cada c√©lula (quadrado) do jogo.
            let gameState;   // Vari√°vel para armazenar o estado atual do jogo.

            /* mapeia cada caractere do mapa a um tipo de elemento do jogo */¬† ¬† ¬† ¬†
            const types = {
                wall: "#",
                player: "@",
                playerOnGoal: "+",
                block: "$",
                blockOnGoal: "*",
                goal: ".",
                empty: " "
            };
     
            /* o mapa do jogo representada por uma string */
            const level1 = `    
      #####
      #   #
      #$  #
    ###  $##
    #  $ $ #
  ### # ## #   ######
  #   # ## #####  ..#
  # $  $          ..#
  ##### ### #@##  ..#
      #     #########
      #######        
      `;

            /*converte a string do mapa em uma matriz 2D */
            const loadLevel = (level) => {
                const linhas = level.split("\n").filter(l => l.trim().length > 0);
                let playerPos = { row: 0, col: 0 };
                let goals = [];

                const board = linhas.map((linha, row) => {
                    return linha.split("").map((c, col) => {
                        if (c === types.player || c === types.playerOnGoal) {
                            playerPos = { row, col };
                        }
                        if (c === types.goal || c === types.playerOnGoal || c === types.blockOnGoal) {
                            goals.push({ row, col });
                        }
                        return c;
                    });
                });

                const width = Math.max(...linhas.map(l => l.length));
                canvas.width = width * grid;
                canvas.height = linhas.length * grid;

                return { board, playerPos, goals };
            };

            /* fun√ßoes para verificar as regras do movimento */
            const isGoal = (board, pos) => {
                const originalCell = board[pos.row]?.[pos.col];
                return originalCell === types.goal || originalCell === types.playerOnGoal || originalCell === types.blockOnGoal;
            };

            const canMove = (board, pos) => {
                const cell = board[pos.row]?.[pos.col] || types.wall;
                return cell === types.empty || cell === types.goal;
            }; 

            const canPushBlock = (board, pos) => {
                const cell = board[pos.row]?.[pos.col] || types.wall;
                return cell === types.block || cell === types.blockOnGoal;
            }; /* permite o movimento do jogador ou das caixas pelo tabuleiro */
               /*cria uma c√≥pia do tabuleiro para gerar imutabilidade e n√£o ferir o paradigma funcional*/

            const moveEntity = (board, fromPos, toPos, isPlayer) => {
                const newBoard = board.map(row => [...row]);
                
                // Determina o que "deixar" na posi√ß√£o original
                newBoard[fromPos.row][fromPos.col] = isGoal(board, fromPos) ? types.goal : types.empty;
                
                // Determina o que "colocar" na nova posi√ß√£o
                const nextCellIsGoal = isGoal(board, toPos);
                if (isPlayer) {
                    newBoard[toPos.row][toPos.col] = nextCellIsGoal ? types.playerOnGoal : types.player;
                } else {
                    newBoard[toPos.row][toPos.col] = nextCellIsGoal ? types.blockOnGoal : types.block;
                }

                return newBoard;
            };
            /*
¬† ¬† ¬† ¬† ¬† ¬†  * A principal fun√ß√£o de l√≥gica. Ela recebe o estado atual e a dire√ß√£o do jogador, calcula o pr√≥ximo estado do jogo e o retorna.
¬† ¬† ¬† ¬† ¬† ¬†  */
            const update = (state, playerDir) => {
                const nextPlayerPos = {
                    row: state.playerPos.row + playerDir.row,
                    col: state.playerPos.col + playerDir.col
                };
                
                let newBoard = state.board;
                let newPlayerPos = state.playerPos;
                // Verifica se o espa√ßo √† frente est√° livre, para a passagem do jogador e das caixas. 
                if (canMove(state.board, nextPlayerPos)) {
                    newBoard = moveEntity(newBoard, newPlayerPos, nextPlayerPos, true);
                    newPlayerPos = nextPlayerPos;
                } else if (canPushBlock(state.board, nextPlayerPos)) {
                    // Se houver uma caixa, verifica se o espa√ßo √† frente da caixa est√° livre.
                    const nextBlockPos = {
                        row: nextPlayerPos.row + playerDir.row,
                        col: nextPlayerPos.col + playerDir.col
                    };
                    
                    if (canMove(state.board, nextBlockPos)) {
                        newBoard = moveEntity(newBoard, nextPlayerPos, nextBlockPos, false);
                        newBoard = moveEntity(newBoard, newPlayerPos, nextPlayerPos, true);
                        newPlayerPos = nextPlayerPos;
                    }
                }
                //retorna o novo estado do jogo 
                return { ...state, board: newBoard, playerPos: newPlayerPos };
            };
            /* Verifica se o jogador venceu. :) */
            const checkWin = (state) => {
                const totalGoals = state.goals.length;
                let blocksOnGoals = 0;
                
                state.goals.forEach(goalPos => {
                    const cell = state.board[goalPos.row]?.[goalPos.col];
                    if (cell === types.blockOnGoal ){
                        blocksOnGoals++;
                    }
                }); // verifica se todas as caixas foram colocadas nos lugares correspondentes

                return totalGoals > 0 && totalGoals === blocksOnGoals;
            };
            
            // Desenha o estado atual do jogo no canvas.
¬† ¬† ¬† ¬† ¬† ¬†  
            const draw = (state) => {
                context.clearRect(0, 0, canvas.width, canvas.height); /* Se a tela n√£o fosse limpa a cada movimento, o jogador deixaria um rastro, 
                e os elementos do jogo seriam desenhados uns por cima dos outros, resultando em uma bagun√ßa visual.*/
                
                state.board.forEach((row, rowIndex) => {
                    row.forEach((cell, colIndex) => {
                        // Desenha o ch√£o e paredes
                        context.fillStyle = "grey";
                        if (cell === types.wall) context.fillStyle = "#ff6600";
                        if (cell === types.empty) context.fillStyle = "#444";
                        
                        // O objetivo √© desenhado no fundo, antes do jogador ou bloco
                        if (cell === types.goal || cell === types.playerOnGoal || cell === types.blockOnGoal) {
                             context.fillStyle = "blue";
                        }
                        context.fillRect(colIndex * grid, rowIndex * grid, grid, grid);
                        
                        // Desenha o jogador e os blocos por cima
                        if (cell === types.player || cell === types.playerOnGoal) {
                            context.fillStyle = "yellow";
                            context.fillRect(colIndex * grid + 4, rowIndex * grid + 4, grid - 8, grid - 8);
                        } else if (cell === types.block || cell === types.blockOnGoal) {
                            context.fillStyle = "brown";
                            context.fillRect(colIndex * grid + 2, rowIndex * grid + 2, grid - 4, grid - 4);
                        }
                    });
                });
                
                if (checkWin(state)) {
                    document.getElementById("tela-vitoria").style.display = "flex";
                }
            };
            /*Identifica a entrada do teclado e chama as fun√ß√µes de l√≥gica e desenho
¬† ¬† ¬† ¬† ¬† ¬†   para atualizar o estado do jogo.
¬† ¬† ¬† ¬† ¬† ¬†  */
            const handleInput = (e) => {
                const playerDir = { row: 0, col: 0 };
                if (e.key === "ArrowUp") playerDir.row = -1;
                if (e.key === "ArrowDown") playerDir.row = 1;
                if (e.key === "ArrowLeft") playerDir.col = -1;
                if (e.key === "ArrowRight") playerDir.col = 1;

                if (playerDir.row !== 0 || playerDir.col !== 0) {
                    gameState = update(gameState, playerDir);
                    draw(gameState);
                }
            };
            /* Inicia o jogo, e tira da tela o menu iniciar.
¬† ¬† ¬† ¬† ¬† ¬†  */
            const iniciarJogo = () => {
                document.getElementById("tela-inicial").style.display = "none";
                document.getElementById("tela-vitoria").style.display = "none";
                gameState = loadLevel(level1);
                draw(gameState);
            };

            const reiniciarJogo = () => iniciarJogo();
            /* Reinicia o jogo ao chamar a fun√ß√£o iniciarJogo(). */
            document.addEventListener("keydown", handleInput);
            window.iniciarJogo = iniciarJogo;
            window.reiniciarJogo = reiniciarJogo;
            // Associa o comando do teclado para capturar a entrada.
            /* Exp√µe as fun√ß√µes 'iniciarJogo' e 'reiniciarJogo' para que possam ser chamadas a partir dos bot√µes no HTML. */

            
            // Inicia o jogo na tela inicial, mas desenha o tabuleiro para que ele apare√ßa atr√°s.
            draw(loadLevel(level1));
        });
    </script>
</body>
</html>

  
