<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sokoban</title>
    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
            background: #000000;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }

        .tela {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0,0,0,0.9);
            z-index: 10;
        }

        .tela h1 {
            font-size: 60px;
            color: #ff6600;
            text-shadow: 3px 3px #000;
        }

        .tela button {
            margin-top: 20px;
            padding: 12px 24px;
            font-size: 20px;
            border: none;
            border-radius: 8px;
            background: #1f1094;
            color: white;
            cursor: pointer;
            transition: 0.3s;
        }

        .tela button:hover {
            background: #2200ff;
        }

        #game {
            border: 2px solid rgb(0, 0, 0);
            background: #000000;
        }
    </style>
</head>
<body>
    <div id="tela-inicial" class="tela">
        <h1>üéÆ Sokoban üéÆ</h1>
        <button onclick="iniciarJogo()">Jogar</button>
    </div>

    <div id="tela-vitoria" class="tela" style="display: none;">
        <h1>üèÜ Voc√™ Venceu! üèÜ</h1>
        <button onclick="reiniciarJogo()">Reiniciar</button>
    </div>

    <canvas id="game" width="1400" height="800"></canvas>

    <script>
        document.addEventListener("DOMContentLoaded", () => {
            const canvas = document.getElementById("game");
            const context = canvas.getContext("2d");
            const grid = 32;
            let gameState;

            const types = {
                wall: "#",
                player: "@",
                playerOnGoal: "+",
                block: "$",
                blockOnGoal: "*",
                goal: ".",
                empty: " "
            };

            const level1 = `    
      #####
      #   #
      #$  #
    ###  $##
    #  $ $ #
  ### # ## #   ######
  #   # ## #####  ..#
  # $  $          ..#
  ##### ### #@##  ..#
      #     #########
      #######        
      `;

            const loadLevel = (level) => {
                const linhas = level.split("\n").filter(l => l.trim().length > 0);
                let playerPos = { row: 0, col: 0 };
                let goals = [];

                const board = linhas.map((linha, row) => {
                    return linha.split("").map((c, col) => {
                        if (c === types.player || c === types.playerOnGoal) {
                            playerPos = { row, col };
                        }
                        if (c === types.goal || c === types.playerOnGoal || c === types.blockOnGoal) {
                            goals.push({ row, col });
                        }
                        return c;
                    });
                });

                const width = Math.max(...linhas.map(l => l.length));
                canvas.width = width * grid;
                canvas.height = linhas.length * grid;

                return { board, playerPos, goals };
            };

            const isGoal = (board, pos) => {
                const originalCell = board[pos.row]?.[pos.col];
                return originalCell === types.goal || originalCell === types.playerOnGoal || originalCell === types.blockOnGoal;
            };

            const canMove = (board, pos) => {
                const cell = board[pos.row]?.[pos.col] || types.wall;
                return cell === types.empty || cell === types.goal;
            };

            const canPushBlock = (board, pos) => {
                const cell = board[pos.row]?.[pos.col] || types.wall;
                return cell === types.block || cell === types.blockOnGoal;
            };

            const moveEntity = (board, fromPos, toPos, isPlayer) => {
                const newBoard = board.map(row => [...row]);
                
                // Determina o que "deixar" na posi√ß√£o original
                newBoard[fromPos.row][fromPos.col] = isGoal(board, fromPos) ? types.goal : types.empty;
                
                // Determina o que "colocar" na nova posi√ß√£o
                const nextCellIsGoal = isGoal(board, toPos);
                if (isPlayer) {
                    newBoard[toPos.row][toPos.col] = nextCellIsGoal ? types.playerOnGoal : types.player;
                } else {
                    newBoard[toPos.row][toPos.col] = nextCellIsGoal ? types.blockOnGoal : types.block;
                }

                return newBoard;
            };

            const update = (state, playerDir) => {
                const nextPlayerPos = {
                    row: state.playerPos.row + playerDir.row,
                    col: state.playerPos.col + playerDir.col
                };
                
                let newBoard = state.board;
                let newPlayerPos = state.playerPos;

                if (canMove(state.board, nextPlayerPos)) {
                    newBoard = moveEntity(newBoard, newPlayerPos, nextPlayerPos, true);
                    newPlayerPos = nextPlayerPos;
                } else if (canPushBlock(state.board, nextPlayerPos)) {
                    const nextBlockPos = {
                        row: nextPlayerPos.row + playerDir.row,
                        col: nextPlayerPos.col + playerDir.col
                    };
                    
                    if (canMove(state.board, nextBlockPos)) {
                        newBoard = moveEntity(newBoard, nextPlayerPos, nextBlockPos, false);
                        newBoard = moveEntity(newBoard, newPlayerPos, nextPlayerPos, true);
                        newPlayerPos = nextPlayerPos;
                    }
                }
                
                return { ...state, board: newBoard, playerPos: newPlayerPos };
            };
            
            const checkWin = (state) => {
                const totalGoals = state.goals.length;
                let blocksOnGoals = 0;
                
                state.goals.forEach(goalPos => {
                    const cell = state.board[goalPos.row]?.[goalPos.col];
                    if (cell === types.blockOnGoal ){
                        blocksOnGoals++;
                    }
                });

                return totalGoals > 0 && totalGoals === blocksOnGoals;
            };

            const draw = (state) => {
                context.clearRect(0, 0, canvas.width, canvas.height);
                
                state.board.forEach((row, rowIndex) => {
                    row.forEach((cell, colIndex) => {
                        // Desenha o ch√£o e paredes
                        context.fillStyle = "grey";
                        if (cell === types.wall) context.fillStyle = "#ff6600";
                        if (cell === types.empty) context.fillStyle = "#444";
                        
                        // O objetivo √© desenhado no fundo, antes do jogador ou bloco
                        if (cell === types.goal || cell === types.playerOnGoal || cell === types.blockOnGoal) {
                             context.fillStyle = "blue";
                        }
                        context.fillRect(colIndex * grid, rowIndex * grid, grid, grid);
                        
                        // Desenha o jogador e os blocos por cima
                        if (cell === types.player || cell === types.playerOnGoal) {
                            context.fillStyle = "yellow";
                            context.fillRect(colIndex * grid + 4, rowIndex * grid + 4, grid - 8, grid - 8);
                        } else if (cell === types.block || cell === types.blockOnGoal) {
                            context.fillStyle = "brown";
                            context.fillRect(colIndex * grid + 2, rowIndex * grid + 2, grid - 4, grid - 4);
                        }
                    });
                });
                
                if (checkWin(state)) {
                    document.getElementById("tela-vitoria").style.display = "flex";
                }
            };
            
            const handleInput = (e) => {
                const playerDir = { row: 0, col: 0 };
                if (e.key === "ArrowUp") playerDir.row = -1;
                if (e.key === "ArrowDown") playerDir.row = 1;
                if (e.key === "ArrowLeft") playerDir.col = -1;
                if (e.key === "ArrowRight") playerDir.col = 1;

                if (playerDir.row !== 0 || playerDir.col !== 0) {
                    gameState = update(gameState, playerDir);
                    draw(gameState);
                }
            };

            const iniciarJogo = () => {
                document.getElementById("tela-inicial").style.display = "none";
                document.getElementById("tela-vitoria").style.display = "none";
                gameState = loadLevel(level1);
                draw(gameState);
            };

            const reiniciarJogo = () => iniciarJogo();

            document.addEventListener("keydown", handleInput);
            window.iniciarJogo = iniciarJogo;
            window.reiniciarJogo = reiniciarJogo;

            // Inicia o jogo na tela inicial, mas desenha o tabuleiro para que ele apare√ßa atr√°s.
            draw(loadLevel(level1));
        });
    </script>
</body>
</html>

  
